% Merging Datasets and Generating Inputs and Outputs in per Hectare Terms in Nigeria General Household Survey, Panel 2012-2013, Wave 2
% Emil Kee-Tui 
% `s c(current_date)`

Total household maize yield (maize production in kilograms per hectare) is generated by dividing the total household maize production by the total area cultivated by a household for maize production. Recall from the crop_output and area_construct chapters that maize production data and area cultivated data are currently in two seperate files. In order to make the variable for the yield we must combine the maize production data with the area cultivation data. 

This chapter covers the procedures to produce variables on input and output per hectare as well as total input and output data, at the household level. Previous files we have thus far prepared are concerned with one type of input or output at the plot level. The purpose of this chapter is to produce a single file that contains all the input and output data at the household level. We will merge all of the preliminary datasets together and then we shall aggregate the data at the household level.

# Merging Datasets

Recall: our observations are identified at the crop level, the plot level, and the household level. When matching, all crops grown on the same plot should be matched to one another; all labor days used on the same plot should be matched to crops grown on that plot, all fertilizer applied to that plot should be matched to the crops grown on that plot and the labor used on that plot etc. The final dataset will be at the household level. To match data relating to the same household plot the two files must contain a household ID variable and a plot ID variable (**hhid** and **plotid**). We are able to identify the observations as belonging to the same household plot when the observations share a household ID and a plot ID. 

Let's now cover the merge itself. We must have one file already open before we start merging all the files together. Choosing the right file is not trivial. We should start with the largest file. Were we to start with a file which contains fewer household ids and plot ids then when we matched a larger file the extra household ids and plot ids would not be matched to the main file. Our largest file is the crop production file. The crop production file is identified for all crops and some crops were grown on the same plot, which means that there are multiple observations with the same plot id and household id.

We use crop output file "ph_secta3.dta" as the master file. We match observations on household id and plot id. During the merge, observations from the merging dataset will match if they possess a household id and plot id that exactly matches a household id and plot id in the master file. Households and plots that did not grow anything will not be present in the crop id; the observations that do not match are those without a crop output. 

```{s}
	use				"$root/wave_2/refined/ph_secta3.dta", clear 
```
	
We made an id variable **cropplot_id** when working on "sect3a_harvestw2.dta". Confirm that it uniquely identifies each observation with the `isid` command. Recall that when a variable uniquely identifies each observation `isid` will not display a result and when a variable fails to uniquely identify the observations `isid` will display an error.

```{s}
	isid			cropplot_id
```
	
Merge in plot size data, "sect11a1_plantingw2.dta", and merge on **hhid** and **plotid**. Multiple crops can be grown on one plot and multiple crops may be matched to the same plot, so; set the matching option to many to one (m:1). `generate(_11a1)` creates a variable called **_11a1** which tells us if an observation matched or failed to match. 

```{s}
	merge 			m:1 hhid plotid using "$root/wave_2/refined/sect11a1_plantingw2.dta", generate(_11a1)
```
	
A failed match from the master occurs if a household id and plot id are present in the master but there is no equal household id and plot id in the using dataset. A failed match from the "using" occurs if a household id and plot id are present in the using dataset but not in the master dataset.

Drop observations that did not match. Observations that did not match are plots that we cannot match to a crop or crops we cannot match to a plot. The only way to identify where a crop was grown or what crop was grown on a plot is the `merge` command we just executed - we cannot do much more. Recall all successful matches have **_11a1**=3. Note “!=” is equivalent to a "not equal" statement so let's use != to drop all observations not equal to 3.

```{s}
quietly	drop			if _11a1 != 3
```

Merge the irrigation dataset, "pp_sect11b1.dta". Use the household id and the plot id for the match.
```{s}
	merge			m:1 hhid plotid using "$root/wave_2/refined/pp_sect11b1.dta", generate(_11b1)
```

A failed match from the master crop file implies that there was no irrigation match. We conclude that if there is no irrigation match to the plot then the plot did not have irrigation. Replace the **irr_any** response for the unmatched from master observations to '2' in order to show that those plots did not have irrigation.
	
```{s}
quietly	replace			irr_any = 2 if irr_any == . & _11b1 == 1
```

Drop the observations from the "using" that are unmerged as we want to limit our observations to the plots with crop data.

```{s}
quietly	drop			if _11b1 == 2
```
	
Merge in planting labor data, "pp_sect11c1.dta".

```{s}
	merge		m:1 hhid plotid using "$root/wave_2/refined/pp_sect11c1.dta", generate(_11c1)
```

Drop unmerged observations from the "using" since we cannot use labor that had no output. We will impute the missing planting labor from the "master" for any plots that had a non-zero crop production, presumably if anything was produced then it used labor to do so. (for the intuition and procedures on imputation refer to the chapter on planting_labor or the imputation section of the yield chapter (hyperlink to those places?))

```{s}
quietly	drop			if _11c1 == 2
```

Merge in pesticide and herbicide use, "pp_sect11c2.dta".

```{s}
	merge		m:1 hhid plotid using "$root/wave_2/refined/pp_sect11c2.dta", generate(_11c2)
```

Failed matches would have occured because there was a household-id-plot-id present in one of the datasets and not the other. We can only confirm that pesticide was or was not used on a plot if they matched succesfully. What should we do about the unmatched observations? Let's consider what the data would look like if we kept the observations which did not match from the "using". The using dataset only contains information on herbicide and pesticide, so we would have no other data on those observations if we kept them in the dataset. What about if we kept the unmatched observations from the "master" file? Unmatched from the "master" have data on crop output, land area, and data from every other dataset we have already matched, but they do not have data on pesticide. We cannot assume that those observations had pesticide so to be on the safe side we should assume that they did not have pesticide use. It is more likely that if a plot had pesticide or herbicide then it would have been recorded in the "using" dataset. Replace the **pest_any** and **herb_any** responses for the unmatched from master observations to '2' in order to show that those plots did not have pesticide or herbicide.

Unfortunately, we must drop the unmatched observations from the "using", those are household-id-plot-ids we know nothing else about besides their pesticide use.

```{s}
quietly	replace			pest_any = 2 if pest_any == . & _11c2 == 1
quietly	replace			herb_any = 2 if herb_any == . & _11c2 == 1
```

Drop the unmerged observations from the using dataset, those observations are plots we do not have cropping data on and therefore cannot use.

```{s}
quietly	drop			if _11c2 == 2
```

Merge the fertilizer dataset, "pp_sect11d.dta".

```{s}
	merge		m:1 hhid plotid using "$root/wave_2/refined/pp_sect11d.dta", generate(_11d)
```

As with the pesticide and herbicide merge, the umatched observations from the "using" dataset lack any other data on them besides fertilizer data. And umatched observations from the "master" dataset do not have fertilizer data but have data from all of the previous dataset merges. We have no information to assume that the plots unmatched from the "master" used fertilizer, so we should assume that those plots did not use fertilizer and replace their fertilizer data with "2", representing that no fertilizer was used on the plot. Drop unmerged observations from the "using" dataset - these are observations that we cannot match to a household or a plot and therefore we cannot use.

```{s}
quietly	drop			if _11d == 2
quietly	replace 		fert_any = 2 if _11d == 1
```

We proceed to merge in harvest labor data.

```{s}
	merge		m:1 hhid plotid using "$root/wave_2/refined/ph_secta2.dta", generate(_a2)
```

As with the planting labor we will impute the unmerged from master later (insert hyperlink to where the imputation occurs) and drop the unmerged from using. 

```{s}
quietly	drop			if _a2 == 2
```

Now all the files have been merged. We have a lot of new variables, so we should drop any unnecessary variables to make the dataset maneagable. The merge variables will not be needed beyond this point, drop them.

```{s}
quietly	drop 			_11a1 _11b _11c1 _11c2 _11d _a2
```

# Creating Plot Level Variables

We now have everything in one place at the crop level, we want to make a set of variables that relate only to maize production, these variables will relate to maize labor, maize land, maize output, all such things that relate to maize. But first there are a few variables we must tidy up: the two labor variables, the fertilizer binary, the pesticide and herbicide binary, and the irrigation binary.

Presently, our binary variables for fertilizer, herbicide, irrigation, and pesticide use 1 and 2 to represent yes and no, respectively. It is a convention in economics to represent a binary with a 0 and a 1. Recode the binary variables so that 0 instead of '2' represents a 'no' response. 

```{s}
quietly	replace			fert_any = 0 if fert_any == 2
quietly	replace			pest_any = 0 if pest_any == 2
quietly	replace			herb_any = 0 if herb_any == 2
quietly	replace			irr_any  = 0 if irr_any  == 2
```

Maize is an important crop and we may want to consider maize inputs and maize output seperately from the other crops or total farm production. We can create maize only variables for land, labor, fertilizer, pesticide, herbicide, and irrigation. We can identify maize observations when maize harvest is non-missing.

```{s}
quietly	gen				mz_lnd = plotsize	if mz_hrv != .
quietly	gen				mz_labhrv = hrv_labor	if mz_hrv != .
quietly	gen				mz_labpp = pp_labor	if mz_hrv != .
quietly	gen				mz_frt = fert_use	if mz_hrv != .
quietly	gen				mz_pst = pest_any	if mz_hrv != .
quietly	gen				mz_hrb = herb_any	if mz_hrv != .
quietly	gen				mz_irr = irr_any	if mz_hrv != .
```

There are a lot of missing observations during the making of the maize observations. The missing observations are the non-maize observations. The maize variables will have non-missing observations when maize was grown and missing observations when maize was not grown.

# Collapsing to the Plot Level

The data is currently at the crop level and we want the data to be at the household level. Between the crop level and the household level is the plot level. The crops are grown on a plot and the plot belongs to the household. We must first collapse the crop level data to the plot level, then we shall collapse the plot level data to the household level. The process of moving from a lower level of data aggregation to a higher level of aggregation is known as collapsing. After collapsing the data, all crops grown on the same plot will be aggregated into one entry. After the collapse, output will be a sum of the total value of all crops grown on that plot.

We use the `collapse` command to aggregate the data to the plot level. Before we collapse note, currently there may be multiple entries for a single plot, the same plot may have matched with multiple crops. We want to condense multiple crop entries into a single entry that summarizes all the crop data for one plot. We have to decide how to aggregate multiple crops, in this case adding them together is best option. Write the option `(sum)' after `collapse' to get the total weight of maize harvested from the plot. Plot size should not be summed because the crops grown on the same plot will have duplicated the same plot size data. Therefore, to create plot size take the maximum value of the plot size. 

Binaries should be collapsed taking the maximum observation. Write the option `(max)' after `collapse' to get the maximum of the binary variable. The observations are either 0 or 1, taking the maximum will preserve the binary. **Labordays** should be collapsed by summation for the same justification as for output, discussed above.

The most important part of the `collapse' command is the level of aggregation of the collapse. At the end of the command we have a `by()' option. In the set of observations that have the same values for the variables in the by option calculate the collapse condition. For instance we could collapse using addition output `by(hhid plotid)', in doing so all observations that share the same **hhid** and **plotid** will be aggregated together.

```{s}
	collapse (sum) mz_vl vl_hrv harv_kg plotsize hrv_labor pp_labor fert_use mz_hrv mz_lnd mz_labhrv mz_labpp mz_frt (max) pest_any herb_any irr_any mz_pst mz_hrb mz_irr mz_damaged, by(hhid plotid plot_id zone state lga sector ea)
```

We want the maize variables to have a missing value whenever an observation did not grow maize. We will replace non-maize observations with missing using a local folder with all the maize variables because we have so many maize variables.

```{s}
	loc	mz			mz_lnd mz_labhrv mz_labpp mz_frt mz_pst mz_hrb mz_irr
	foreach v of varlist `mz'{
	    replace		`v' = . if mz_damaged == . & mz_hrv == 0	
	}	
	replace			mz_hrv = . if mz_damaged == . & mz_hrv == 0		
	drop 			mz_damaged
```
	
Now that the data is at the plot level we should make the variables that are at the plot level such as maize yield (USD/ha).




# Plot Maize Yield (kg/ha).

```{s}
quietly	gen			mz_yld = mz_hrv / mz_lnd
quietly	lab var		mz_yld	"maize yield (kg/ha)"
```

It is important to summarize the variable we have just produced, at a quick glance we can check for glaring mistakes. Look at the summary statistics: mean values, maximum values, and minimum values. We want to make sure that the data reflects something about what we know the actual production in Nigeria.

```{s}
	sum 		mz_yld, detail
```

The **mz_yld** turns out to have large values. We should replace the very large outliers and impute the missing observations outliers. We have repeated the steps to impute many times in the previous chapters so for brevity we will not describe here how imputation works (see crop_output chapter), we will lay out the steps and highlight the parts of the code which are specific to this case. 

As with any imputation we must first decide which outliers we wish to target. Observations which are greater than three standard deviations from the mean we will change to missing. Take note of the number of observations that are above three standard deviations from the mean and get replaced with missing, we will match this number to the number of observations we replace with imputations in a few steps.

```{s}
	replace 	mz_yld = . if mz_yld > `r(p50)' + (3*`r(sd)')
```

`Mi` (multiple imputation) is the Stata command for imputing. Set the data structure as wide or long. Our data is wide because a unique observation is identified by a unique row.

```{s}

quietly	mi set 			wide 
```	
Clear any time series settings you may have in place or else the time series will interfere with the linear regression we run later.
```{s}

quietly	mi xtset		, clear 
```
Register **mz_yld** as the variable we will be imputing.
	
```{s}

quietly	mi register 	imputed mz_yld
```
Sort the data to ensure reproducibility. Sorting the data can be done at any stage before the actual imputation. Data is uniquely identified by **hhid** **plotid**. 

```{s}

quietly	sort			hhid plotid, stable 
```
	
Use predictive mean matching (pmm) to impute the data, the regression in the imputation has **mz_yld** for the dependent variable and **i.state** (a dummy for each state) as the independent variable. Enable the impute option "force" which enables the regression to run even if an error occurs; "knn(#)" determines the number of non-missing **mz_yld** observations to match to the estimate, for example we choose to match to the nearest 5 observations; "bootstrap" samples the data with replacement and regresses on the bootstapped sample; "rseed(#)" specifies the random number seed used to create the sample. 


```{s}
	quietly mi impute 		pmm mz_yld i.state, add(1) rseed(245780) noisily dots ///
						force knn(5) bootstrap
```
Declare the imputing to be over by `mi unset`.

```{s}

	quietly mi unset
```

Do the changes look reasonable? If they are reasonable then we can replace the missing values with the imputed values.

```{s}
	replace			mz_yld = mz_yld_1_ if mz_lnd != .
```
How many observations were replaced in the previous stage? Was it the same number of observations we made missing? If the number of missing values is the same as the number of values replaced with imputation then we have succesfully imputed the relevant values and we can move on.

```{s}
quietly	drop 			mz_yld_1_
```

What has the imputation done to **mz_yld**?

```{s}
sum 		mz_yld, detail
```

The maximum **mz_yld** is 26690.39, this is still a little too high. Let's impute again.

```{s}
	replace 	mz_yld = . if mz_yld > `r(p50)' + (3*`r(sd)')

quietly	mi set 			wide 

quietly	mi xtset		, clear 

quietly	mi register 	imputed mz_yld

quietly	sort			hhid plotid, stable 

	quietly mi impute 		pmm mz_yld i.state, add(1) rseed(245780) noisily dots force knn(5) bootstrap

	quietly mi unset

	replace			mz_yld = mz_yld_1_ if mz_lnd != .

quietly	drop 			mz_yld_1_
```

What has the second imputation done to **mz_yld**?

```{s}
sum 		mz_yld

```
The new maximum **mz_yld** is 10606.68. Half of what it was before. Let's move on for now. If we need to impute this variable again we will do so when we collapse everything to the household level.

The maize yield variable is imputed meaning its different from what it was when we first labeled it. Label the imputed variable to track the imputation.

```{s}
quietly	lab var 		mz_yld "maize yield (kg/ha), imputed"
```
Having now cleaned **mz_yld (kg/ha)** we can calculate the total maize output for a field by multiplying the yield with the plotsize.

```{s}
quietly	generate 		mz_hrvimp = mz_yld * mz_lnd
quietly	lab var 		mz_hrvimp "maize harvest quantity (kg), imputed"
```




# Value of Maize Harvested (USD/ha)

```{s}
quietly	gen 		mz_value = mz_vl / mz_lnd
quietly	lab var 	mz_value "maize value (USD/ha)"

	sum 		mz_value, detail

	replace 	mz_value = . if mz_value > `r(p50)' + (3*`r(sd)')
```

For the sake of brevity we have included the imputation code for **mz_value** but we have not included any discussion of our approach to imputation (refer to chapter crop_output for a discussion about imputation).

```{s}
quietly	mi set 			wide 

quietly	mi xtset		, clear 

quietly	mi register 	imputed mz_value

quietly	sort			hhid plotid, stable 

	quietly mi impute 		pmm mz_value i.state, add(1) rseed(245780) noisily dots ///
						force knn(5) bootstrap

	quietly mi unset

	replace			mz_value = mz_value_1_ if mz_lnd != .
	
quietly	drop 			mz_value_1_

sum mz_value
```

After imputation the new **mz_value** is 14547.45, that's a more reliable number.







# Harvest Labor Days per Hectare, Maize (days/ha)

Create the maize labor used per hectare variable.

```{s}
quietly	gen 		labordayshrv_ha_mz = hrv_labor/plotsize
quietly	label var 	labordayshrv_ha_mz "maize labor use harvest (days/ha)"
```
Summarize the maize labor per hectare to obtain the standard deviation, all observations above three standard deviations from the mean will be replaced with missing values and imputed.
```{s}
	sum 		labordayshrv_ha_mz, detail

	replace 	labordayshrv_ha_mz = . if labordayshrv_ha_mz > `r(p50)' + (3*`r(sd)')
```

Impute the missing observations.

```{s}
quietly	mi set 			wide 

quietly	mi xtset		, clear 

quietly	mi register 	imputed labordayshrv_ha_mz

quietly	sort			hhid plotid, stable 

	quietly mi impute 		pmm labordayshrv_ha_mz i.state, add(1) rseed(245780) noisily dots ///
						force knn(5) bootstrap

	quietly mi unset

	replace			labordayshrv_ha_mz = labordayshrv_ha_mz_1_
	
quietly	drop 			labordayshrv_ha_mz_1_
```

Label the maize labor variable to keep track of that the variable has been imputed.

```{s}
quietly		lab var			labordayshrv_ha_mz	"maize labor use harvest (days/ha), imputed"
```

What has imputation done to **labordayshrv_ha_mz**?

```{s}
sum 	labordayshrv_ha_mz
```

The new maximum value of **labordayshrv_ha_mz** is 2830.492, that is a much more reliable figure.

Infer total maize labor use with the per hectare labor use.

```{s}
quietly	gen				mz_labhrvimp = labordayshrv_ha_mz * mz_lnd
quietly	lab var			mz_labhrvimp "maize labor harvest (days), imputed"
```





# Planting Labor Days Per Hectare, Maize  (days/ha)

Create the maize planting labor used per hectare variable.

```{s}
quietly	gen 		labordayspp_ha_mz = pp_labor/plotsize
quietly	label var 	labordayspp_ha_mz "maize labor use planting (days/ha)"
```
Summarize the maize planting labor per hectare to obtain the standard deviation, all observations above three standard deviations from the mean will be replaced with missing values and imputed.
```{s}
	sum 		labordayspp_ha_mz, detail

	replace 	labordayspp_ha_mz = . if labordayspp_ha_mz > `r(p50)' + (3*`r(sd)')
```

Impute the missing observations.

```{s}
quietly	mi set 			wide 

quietly	mi xtset		, clear 

quietly	mi register 	imputed labordayspp_ha_mz

quietly	sort			hhid plotid, stable 

	quietly mi impute 		pmm labordayspp_ha_mz i.state, add(1) rseed(245780) noisily dots ///
						force knn(5) bootstrap

	quietly mi unset

	replace			labordayspp_ha_mz = labordayspp_ha_mz_1_
	
quietly	drop 			labordayspp_ha_mz_1_
```

What has imputation done to **labordayspp_ha_mz**?
```{s}
sum 			labordayspp_ha_mz
```

The new maximum value is 12170.17. This seems a bit too high so we will impute a second time. 

```{s}
	sum 		labordayspp_ha_mz, detail

	replace 	labordayspp_ha_mz = . if labordayspp_ha_mz > `r(p50)' + (3*`r(sd)')
```

Impute the missing observations.

```{s}
quietly	mi set 			wide 

quietly	mi xtset		, clear 

quietly	mi register 	imputed labordayspp_ha_mz

quietly	sort			hhid plotid, stable 

	quietly mi impute 		pmm labordayspp_ha_mz i.state, add(1) rseed(245780) noisily dots ///
						force knn(5) bootstrap

	quietly mi unset

	replace			labordayspp_ha_mz = labordayspp_ha_mz_1_
	
quietly	drop 			labordayspp_ha_mz_1_
```

What has imputation done to **labordayspp_ha_mz**?
```{s}
sum 			labordayspp_ha_mz
```
The new maximum is 5847. We will accept this new maximum value and move on.

Label the maize labor planting variable to keep track of that the variable has been imputed.

```{s}
quietly		lab var			labordayspp_ha_mz	"maize labor use planting (days/ha), imputed"
```

Infer total maize labor planting use with the per hectare labor use.

```{s}
quietly	gen				mz_labppimp = labordayshrv_ha_mz * mz_lnd
quietly	lab var			mz_labppimp "maize labor planting (days), imputed"
```



# Fertilizer Application Per Hectare, Maize (kg/ha)

Create the fertilizer use variable. Fertilizer use is measured as kilograms of fertilizer applied per hectare.

```{s}
quietly	gen 		fert_use_ha_mz = fert_use/plotsize if mz_lnd != .
quietly	label var 	fert_use_ha_mz "fertilizer applied per hectare, maize (kg/ha)"
```

Summarize the fertilizer use per hectare to obtain the standard deviation, all observations above three standard deviations from the mean will be replaced with missing values and imputed.

```{s}
	sum 		fert_use_ha_mz, detail
	replace 	fert_use_ha_mz = . if fert_use_ha_mz > `r(p50)' + (3*`r(sd)')
```
Impute the missing fertilizer use values.

```{s}
quietly	mi set 			wide 

quietly	mi xtset		, clear 

quietly	mi register 	imputed fert_use_ha_mz

quietly	sort			hhid plotid, stable 

	quietly mi impute 		pmm fert_use_ha_mz i.state, add(1) rseed(245780) noisily dots ///
						force knn(5) bootstrap

	quietly mi unset

	replace			fert_use_ha_mz = fert_use_ha_mz_1_
	
quietly	drop 			fert_use_ha_mz_1_
```

Label the fertililzer variable to keep track of the imputation.

```{s}
quietly	label		var	fert_use_ha_mz "fertilizer applied per hectare, maize (kg/ha) imputed"
```
What does the imputation look like? 
```{s}
sum  				fert_use_ha_mz
```
The new maximum value of **fert_use_ha_mz** is 2494.501, this looks good!

Infer the total fertilizer used from the per hectare measure.

```{s}
quietly	gen				mz_frtimp = fert_use_ha_mz * mz_lnd
quietly	lab var			mz_frtimp "fertilizer (kg), imputed"
```





# The Value of the Harvest (USD/ha)

Generate harvest value and give it a label. Harvest value is a per hectare measurement of the value of crop output per hectare of land.

```{s}
quietly	gen 		harv_value = vl_hrv/plotsize if mz_hrv != .
quietly	label var 	harv_value "total value of crop harvest (USD/ha)"
```

Summarize **harv_value** to obtain the standard deviation, replace the values outside of three standard deviations as missing in preperation for the imputation. We will make a note of the observations that are three standard deviations above the mean with a binary variable **harv_vl_missimp**; we will use this variable to only replace the values we made missing with imputed observations.

```{s}
	 sum 		harv_value, detail
```	 
	 
The maximum **harv_value** is 26152.57. This is a little too high so we will need to impute the large outliers.

```{s}
	gen 		harv_vl_missimp = 1 if harv_value > `r(p50)' + (3*`r(sd)') & harv_value != .
	replace 	harv_value = . if harv_value > `r(p50)' + (3*`r(sd)')
```
Impute the missing variables.

```{s}
quietly	mi set 			wide 

quietly	mi xtset		, clear 

quietly	mi register 	imputed harv_value

quietly	sort			hhid plotid, stable 

	quietly mi impute 		pmm harv_value i.state, add(1) rseed(245780) noisily dots ///
						force knn(5) bootstrap

	quietly mi unset
```
Now using the variable **harv_vl_missimp** we can ensure that only the observations we made missing are replaced with imputations. 

```{s}
	replace			harv_value = harv_value_1_ if harv_vl_missimp == 1
	
quietly	drop 			harv_value_1_
	
```

Label the imputed variable to keep track of the imputation.

```{s}
quietly	lab var			harv_value	"value of yield (2010USD/ha), imputed"
```
Calculate the total value of the harvest by multiplying the imputed value of crop per hectare with the land area.

```{s}
quietly	generate		vl_hrvimp = harv_value * plotsize 
quietly	lab var			vl_hrvimp "value of harvest (2010USD), imputed"
quietly lab var			vl_hrv "value of harvest (2010USD)"
sum 					vl_hrvimp
```
The maximum of **vl_hrvimp** is now 3151.023. The maximum value of **harv_value** is now  6309.617.





# Total Labor Days Harvest per Hectare (days/ha)

We now generate and refine the variable measuring the labor days used per hectare of plotsize.

```{s}
quietly	gen 		labordayshrv_ha = hrv_labor/plotsize
quietly	label var 	labordayshrv_ha "farm labor use (labordays/ha)"
```

We will have to impute the variable if the values in the extreme are too extreme, normally they are too high.

```{s}
	sum 		labordayshrv_ha, detail
```
The highest value is 94807.82, this appears to be too many labor days per hectare. We will impute the values that lie outside three standard deviations of the mean, and make a note of these observations we replace with missing.

```{s}
	gen 		labordayshrv_missimp = 1 if labordayshrv_ha > `r(p50)' + (3*`r(sd)') & labordayshrv_ha != .
	replace 	labordayshrv_ha = . if labordayshrv_ha > `r(p50)' + (3*`r(sd)')
```

We replaced 89 observations with missing values.
```{s}
quietly	mi set 			wide 

quietly	mi xtset		, clear 

quietly	mi register 	imputed labordayshrv_ha

quietly	sort			hhid plotid, stable 

	quietly mi impute 		pmm labordayshrv_ha i.state, add(1) rseed(245780) noisily dots ///
						force knn(5) bootstrap

	quietly mi unset

	replace			labordayshrv_ha = labordayshrv_ha_1_ if labordayshrv_missimp == 1
```{s}

We replaced 89 observations with imputations, the same number we replaced before with missing values.
	
```{s}	
quietly	drop 			labordayshrv_ha_1_
```

Label the labordays variable to indicate it has undergone imputing and differentiate it from the first version of the variable we created.

```{s}
quietly	lab var			labordayshrv_ha	"farm labor use (days/ha), imputed"
```
What does the imputed **labordayshrv_ha** look like?

```{s}
sum 	labordayshrv_ha
```
The new maximum value of **labordayshrv_ha** is 2830.492. This is much better.

Infer the total labor used on the plot by multiplying the imputed labor per hectare with the plotsize.

```{s}
quietly	gen				labordayshrvimp = labordayshrv_ha * plotsize
quietly	lab var			labordayshrvimp "farm labor (days), imputed"
```




# Total Labor Days Planting per Hectare (days/ha)

We now generate and refine the variable measuring the labor days used per hectare of plotsize.

```{s}
quietly	gen 		labordayspp_ha = pp_labor/plotsize
quietly	label var 	labordayspp_ha "farm labor use planting (labordays/ha)"
```

We will have to impute the variable if the values in the extreme are too extreme, normally they are too high.

```{s}
	sum 		labordayspp_ha, detail
```
The highest value is  86311.53, this appears to be too many labor days per hectare. We will impute the values that lie outside three standard deviations of the mean. We also make a variable to note which observations we replaced with missing values.

```{s}
	gen 		labordayspp_missimp = 1 if labordayspp_ha > `r(p50)' + (3*`r(sd)') & labordayspp_ha != .
	replace 	labordayspp_ha = . if labordayspp_ha > `r(p50)' + (3*`r(sd)')
```
We replaced 90 observations with missing values.

```{s}

quietly	mi set 			wide 

quietly	mi xtset		, clear 

quietly	mi register 	imputed labordayspp_ha

quietly	sort			hhid plotid, stable 

	quietly mi impute 		pmm labordayspp_ha i.state, add(1) rseed(245780) noisily dots ///
						force knn(5) bootstrap

	quietly mi unset

	replace			labordayspp_ha = labordayspp_ha_1_ if labordayspp_missimp == 1
	
quietly	drop 			labordayspp_ha_1_
drop labordayspp_missimp
```
We replaced 90 observations with imputations, this matches the number of observations we made missing.

Label the labordays variable to indicate it has undergone imputing and differentiate it from the first version of the variable we created.

```{s}
quietly	lab var			labordayspp_ha	"farm labor use planting (days/ha), imputed"
sum 				labordayspp_ha
```
The maximum **labordayspp_ha** is 12170. This is still very high. We should impute again.

```{s}
	sum 		labordayspp_ha, detail
	gen 		labordayspp_missimp = 1 if labordayspp_ha > `r(p50)' + (3*`r(sd)') & labordayspp_ha != .
	replace 	labordayspp_ha = . if labordayspp_ha > `r(p50)' + (3*`r(sd)')
```
We replaced 200 observations with missing values.

```{s}

quietly	mi set 			wide 

quietly	mi xtset		, clear 

quietly	mi register 	imputed labordayspp_ha

quietly	sort			hhid plotid, stable 

	quietly mi impute 		pmm labordayspp_ha i.state, add(1) rseed(245780) noisily dots ///
						force knn(5) bootstrap

	quietly mi unset

	replace			labordayspp_ha = labordayspp_ha_1_ if labordayspp_missimp == 1
	
quietly	drop 			labordayspp_ha_1_
drop labordayspp_missimp
sum 			labordayspp_ha
```

The new maximum for **labordayspp_ha** is 5847.953. This is much better.

Infer the total labor used on the plot by multiplying the imputed labor per hectare with the plotsize.

```{s}
quietly	gen				labordaysppimp = labordayspp_ha * plotsize
quietly	lab var			labordaysppimp "farm labor planting (days), imputed"
sum 					labordaysppimp
```
The maximum **labordaysppimp** is 5790.






# Fertilizer Application per Hectare (kg/ha)

Generate the variable measuring the amount of fertilizer applied to each hectare of each plot.
```{s}
quietly	gen 		fert_use_ha = fert_use/plotsize
quietly	label var 	fert_use_ha "fertilizer applied per hectare (kg/ha)"
```
Take the summary of **fert_use_ha** to determine if it's values are too large.

```{s}
	 sum 		fert_use_ha, detail
```
The maximum is too high and a bit unreasonable. We will replace the outliers by imputation.

```{s}
	replace 	fert_use_ha = . if fert_use_ha > `r(p50)' + (3*`r(sd)')
	
quietly	mi set 			wide 

quietly	mi xtset		, clear 

quietly	mi register 	imputed fert_use_ha

quietly	sort			hhid plotid, stable 

	quietly mi impute 		pmm fert_use_ha i.state, add(1) rseed(245780) noisily dots ///
						force knn(5) bootstrap

	quietly mi unset

	replace			fert_use_ha = fert_use_ha_1_
	
quietly	drop 			fert_use_ha_1_
```

What has the imputation done to the distribution of **fert_use_ha**?

```{s}
sum fert_use_ha
```
The new maximum value of **fert_use_ha** is 2215.674, that's much better than before.

label the fertililzer use variable to indicate it has undergone imputing.

```{s}
quietly	lab var			fert_use_ha	"fertilizer applied per hectare (kg/ha), imputed"
```

Infer the total fertilizer used on the plot by multiplying the imputed rate at which fertilizer is applied by the plot area.

```{s}
quietly	gen fertimp = fert_use_ha*plotsize
```




	





# Plot Total Crop Yield (kg/ha)

Generate yield of all crops on each plot. Yield is measured in kilograms of output per hectare. Generate total plot yield by dividing **harv_kg**, the weight of all crops harvested on the plot, by **plotsize**, the size of the plot in hectares.

```{s}
quietly	gen 		kg_yld = harv_kg / plotsize
quietly	label var   kg_yld "total crop yield (kg/ha)"
```

Summarize **kg_yld**, notice the extreme values, if the values appear to be too large then we will replace the high values with missing values and impute the missing values.

```{s}
	sum 		kg_yld, detail
```

The maximum value is 2114473 kg/ha, clearly this is unrealistic. Replace all values that are greater than three standard deviations from the mean.

```{s}
	replace 	kg_yld = . if kg_yld > `r(p50)' + (3*`r(sd)')
```

Take the steps to impute the values in **kg_yld** that we replaced with missing values.

```{s}

quietly	mi set 			wide 

quietly	mi xtset		, clear 

quietly	mi register 	imputed kg_yld

quietly	sort			hhid plotid, stable 

	quietly mi impute 		pmm kg_yld i.state, add(1) rseed(245780) noisily dots ///
						force knn(5) bootstrap

	quietly mi unset

	replace			kg_yld = kg_yld_1_
	
quietly	drop 			kg_yld_1_
```
What has imputation changed?

```{s}
sum kg_yld, detail
```
The yield is 116000, which is still too high. We should impute again.

```{s}
	replace 	kg_yld = . if kg_yld > `r(p50)' + (3*`r(sd)')
```

Take the steps to impute the values in **kg_yld** that we replaced with missing values.

```{s}

quietly	mi set 			wide 

quietly	mi xtset		, clear 

quietly	mi register 	imputed kg_yld

quietly	sort			hhid plotid, stable 

	quietly mi impute 		pmm kg_yld i.state, add(1) rseed(245780) noisily dots ///
						force knn(5) bootstrap

	quietly mi unset

	replace			kg_yld = kg_yld_1_
	
quietly	drop 			kg_yld_1_
```
How has the maximum value of **kg_yld** changed now?

```{s}
sum 				kg_yld, detail
```
The maximum value is 35826.88. This is still too high. Let's impute again.

```{s}
	replace 	kg_yld = . if kg_yld > `r(p50)' + (3*`r(sd)')
```

Take the steps to impute the values in **kg_yld** that we replaced with missing values.

```{s}

quietly	mi set 			wide 

quietly	mi xtset		, clear 

quietly	mi register 	imputed kg_yld

quietly	sort			hhid plotid, stable 

	quietly mi impute 		pmm kg_yld i.state, add(1) rseed(245780) noisily dots ///
						force knn(5) bootstrap

	quietly mi unset

	replace			kg_yld = kg_yld_1_
	
quietly	drop 			kg_yld_1_
```
How does the third imputation look?

```{s}
sum 				kg_yld, detail
```

The new maximum is 17316.5. This is high so let's impute one last time.


```{s}
	replace 	kg_yld = . if kg_yld > `r(p50)' + (3*`r(sd)')
```

Take the steps to impute the values in **kg_yld** that we replaced with missing values.

```{s}

quietly	mi set 			wide 

quietly	mi xtset		, clear 

quietly	mi register 	imputed kg_yld

quietly	sort			hhid plotid, stable 

	quietly mi impute 		pmm kg_yld i.state, add(1) rseed(245780) noisily dots ///
						force knn(5) bootstrap

	quietly mi unset

	replace			kg_yld = kg_yld_1_
	
quietly	drop 			kg_yld_1_
```
How does the fourth imputation look? The new max is 11108.03, this is much better so let's move on.




# Collapsing to the Household Level

We now have variables in per hectare terms at the plot level. The next step for us to take is to generate household-level variables. The household-level variables are a summation of the plot level variables we have so far been working with. For instance the household-level variable for plot area will be the sum of the area of all plots owned by a household. Moving from plot-level to household-level is known as a `collapse`. 

We make the household level variable by summarizing the values within a household. This is such that the new value for a household's observation in a particular variable is the sum of all plot values.

For total household land, by hhid take the sum of all plotsizes with a unique plot_id.
```{s}
quietly	bysort			hhid (plot_id) : egen tf_lnd = sum(plotsize)
```
We must name the new variable. 

```{s}
quietly	lab var			tf_lnd	"Total farmed area (ha)"
```

Consider that land measurements must be positive and because we will be dividing by land measurements to generate per hectare variables land must be non-zero. We can force the data to be non-zero and non-negative by asserting a non-negative non-zero condition on **tf_lnd**. The `assert` command will notify us if any observations do not meet the conditions: at least negative observations are definitely errors; true zero land observations should be dropped because a crop cannot be grown on no land.

```{s}
quietly	assert			tf_lnd > 0 
```

For total household harvest, by hhid take the sum of all harvest which come from a unique plot_id.

```{s}
quietly	bysort			hhid (plot_id) : egen tf_hrv = sum(vl_hrvimp)
```

We must label the new variable. 

```{s}
quietly	lab var			tf_hrv	"Total value of harvest (2010 USD)"
```
	
We now make the total yield variable. The total yield is the total harvest value divided by the total land. All observations from the same household have the same values for **tf_hrv** and **tf_lnd**, thus **tf_yld** will also have the same values for all observations which have the same household id. 

```{s}
quietly	generate		tf_yld = tf_hrv / tf_lnd
``` 

Label the new variable.

```{s}
quietly	lab var			tf_yld	"value of yield (2010 USD/ha)"
``` 

For total labor we will generate a new variable which is the sum of all plot harvest labor by household.

```{s}
quietly	bysort 			hhid (plot_id) : egen lab_hrv = sum(labordayshrv_ha)
``` 

We now make the total labor per hectare. The total harvest labor per hectare is the total harvest labor divided by the total land area. All observations from the same household have the same values for **lab_tot** and **tf_lnd**, thus **tf_lab** will also have the same values for all observations which have the same household id. 

```{s}
quietly	generate		tf_labhrv = lab_hrv / tf_lnd
``` 

Label the new variable.

```{s}
quietly	lab var			tf_labhrv	"labor rate during harvest (days/ha)"
```

For total planting labor we will generate a new variable which is the sum of all plot level planting labor by household.

```{s}
quietly	bysort 			hhid (plot_id) : egen lab_pp = sum(labordayspp_ha)
``` 

We now make the total labor per hectare. The total labor is the total labor divided by the total land. All observations from the same household have the same values for **lab_tot** and **tf_lnd**, thus **tf_lab** will also have the same values for all observations which have the same household id. 

```{s}
quietly	generate		tf_labpp = lab_pp / tf_lnd
``` 

Label the new variable.

```{s}
quietly	lab var			tf_labpp	"labor rate during planting (days/ha)"
```

For total fertilizer we will generate a new variable which is the sum of all plot fertilizer by household.

```{s}
quietly	bysort 			hhid (plot_id) : egen fert_tot = sum(fertimp)
``` 
We now make the total fertilizer per hectare variable. The total fertilizer is the total fertilizer value divided by the total land. All observations from the same household have the same values for **fert_tot** and **tf_lnd**, thus **tf_frt** will also have the same values for all observations which have the same household id.

```{s}
quietly	generate		tf_frt = fert_tot / tf_lnd
``` 

Label the new variable.

```{s}
quietly	lab var			tf_frt	"fertilizer rate (kg/ha)"
``` 

For irrigation, pesticide and herbicide use we can only say that it was or was not used. We can be contented to represent "use" or "not use" with a binary that pesticide/herbicide/irrigation was applied on at least one of the household's plots. We generate the binary variables for pesticide/herbicide/irrigation by taking the maximum value of **irr_any**/ **pest_any**/ **herb_any** within all plots in a household. The values can only be 1 or 0 so the maximum will be 1, if the maximum is 1 then we can say at least one plot had pesticide/herbicide/irrigation.

```{s}
quietly	bysort 			hhid (plot_id) : egen tf_pst = max(pest_any)
quietly	bysort 			hhid (plot_id) : egen tf_hrb = max(herb_any)
quietly	bysort 			hhid (plot_id) : egen tf_irr = max(irr_any)
``` 
Label the variables.

```{s}
quietly	lab var			tf_pst	"Any plot has pesticide"
quietly	lab var			tf_hrb	"Any plot has herbicide"
quietly	lab var			tf_irr	"Any plot has irrigation"
``` 

Let's now generate household level maize variables, we will use the same procedures as the household level total farm variables.

For household maize land, by hhid take the sum of all maize plotsizes with a unique maize plot_id.

```{s}
quietly	bysort			hhid (plot_id) :	egen cp_lnd = sum(mz_lnd) if mz_hrvimp != .
```

For household maize harvest, by hhid take the sum of all harvest which come from a unique maize plot_id.

```{s}
quietly	bysort			hhid (plot_id) :	egen cp_hrv = sum(mz_hrvimp) if mz_hrvimp != .
```
	
The process can be repeated similarly for labor. For household maize yield, by hhid divide the maize harvest by the maize land from a unique maize plot_id.

```{s}
quietly	generate		cp_yld = cp_hrv / cp_lnd if mz_hrvimp != .
```
	
For household maize harvest labor, by hhid take the sum of all harvest labor which come from a unique maize plot_id.

```{s}
quietly	bysort 			hhid (plot_id) : egen labhrv_mz = sum(mz_labhrvimp)	if mz_hrvimp != .
```

The process can be repeated similarly for labor. For the household rate at which labor was applied to maize fields, by hhid divide the maize labor by the maize land from a unique maize plot_id.

```{s}
quietly	generate		cp_labhrv = labhrv_mz / cp_lnd
```

For household maize planting labor, by hhid take the sum of all planting labor which come from a unique maize plot_id.

```{s}
quietly	bysort 			hhid (plot_id) : egen labpp_mz = sum(mz_labppimp)	if mz_hrvimp != .
```

The process can be repeated similarly for labor. For the household rate at which labor was applied to maize fields, by hhid divide the maize labor by the maize land from a unique maize plot_id.

```{s}
quietly	generate		cp_labpp = labpp_mz / cp_lnd
```

For the household rate at which fertilizer was applied to maize fields, by hhid divide the maize fertilizer by the maize land from a unique maize plot_id.

```{s}
quietly	bysort 			hhid (plot_id) : egen fert_mz = sum(mz_frtimp) if mz_hrvimp != .
quietly	generate		cp_frt = fert_mz / cp_lnd
```

Again, for pesticide and herbicide we do not have the amount of pesticide or herbicide or irrigation so we can be contented to represent the binary that pesticide was applied on a plot to an equivalent binary that a household used pesticide on at least one of their plots. Generate the "use" or "not use" binary by taking the maximum **irr_any**/ **pest_any**/ **herb_any** binary value for all plots used by a household. One difference from **tf_pst**/ **tf_hrb**/ **tf_irr** is that now we want a variable for those used for maize. Only take observations that have a non-missing maize harvest.

```{s}
quietly	bysort 			hhid (plot_id) : egen cp_pst = max(pest_any) if mz_hrvimp != .
quietly	bysort 			hhid (plot_id) : egen cp_hrb = max(herb_any) if mz_hrvimp != .
quietly	bysort 			hhid (plot_id) : egen cp_irr = max(irr_any) if mz_hrvimp != .
``` 	
	
 Presently, each household has one observation per plot and every observation is the same and at the household level. Our objective now, however is to be left with one observation per household. Since the observations are identical it does not matter how we choose which observation to keep, we will collapse the observations into one for each household and take the observation within the household that is the maximum, they are all the maximum because they are the same, maximum still returns one observation even when all the observations are the same.

```{s}
quietly	collapse (max)	tf_* cp_*, by(zone state lga sector ea hhid)		
```
All at once we're going to label the new variables.

```{s}
quietly	lab var			tf_lnd	"Total farmed area (ha)"
quietly	lab var			tf_hrv	"Total value of harvest (2010 USD)"
quietly	lab var			tf_yld	"value of yield (2010 USD/ha)"
quietly	lab var			tf_labhrv	"labor rate harvest (days/ha)"
quietly	lab var			tf_labpp	"labor rate planting (days/ha)"
quietly	lab var			tf_frt	"fertilizer rate (kg/ha)"
quietly	lab var			tf_pst	"Any plot has pesticide"
quietly	lab var			tf_hrb	"Any plot has herbicide"
quietly	lab var			tf_irr	"Any plot has irrigation"
quietly	lab var			cp_lnd	"Total maize area (ha)"
quietly	lab var			cp_hrv	"Total quantity of maize harvest (kg)"
quietly	lab var			cp_yld	"Maize yield (kg/ha)"
quietly	lab var			cp_labhrv	"labor rate for maize harvest (days/ha)"
quietly	lab var			cp_labpp	"labor rate for maize planting (days/ha)"
quietly	lab var			cp_frt	"fertilizer rate for maize (kg/ha)"
quietly	lab var			cp_pst	"Any maize plot has pesticide"
quietly	lab var			cp_hrb	"Any maize plot has herbicide"
quietly	lab var			cp_irr	"Any maize plot has irrigation"
```

Summarize all the variables we have at this point so we can determine that the observations are not unreasonable. If they are unreasonable we will impute the values of the variables that are unreasonable.
	
```{s}
	sum				tf_* cp_*
```

# Cleaning Harvest Labor Variables

After the collapse the mean and maximum values of **tf_labhrv** became extremely high. Let's take a closer look at the variable to see what is going on.

```{s}
	sum				tf_labhrv, detail
```

The top one percent of values of **tf_labhrv** are driving the high means. So let's remove the outliers with an imputation. For the sake of brevity we will provide the imputation code without much explanation, the steps for imputation are almost exactly the same as all the imputations we have already done. The only difference is **tf_labhrv** is the variable we are imputing.

```{s}
	replace 	tf_labhrv = . if tf_labhrv > `r(p50)' + (3*`r(sd)')
```

Take the steps to impute the values in **tf_labhrv** that we replaced with missing values.

```{s}

quietly	mi set 			wide 

quietly	mi xtset		, clear 

quietly	mi register 	imputed tf_labhrv

quietly	sort			hhid, stable 

	quietly mi impute 		pmm tf_labhrv i.state, add(1) rseed(245780) noisily dots ///
						force knn(5) bootstrap

	quietly mi unset

	replace			tf_labhrv = tf_labhrv_1_
	
quietly	drop 			tf_labhrv_1_
```
How has the maximum value of **tf_labhrv** changed now?

```{s}
sum 				tf_labhrv, detail
```
The maximum value is still too high. The standard deviation we used to replace the first few observations of **tf_labhrv** was very large because the outliers were so large, but we still did not remove enough outliers. Let's impute again.

```{s}
	replace 	tf_labhrv = . if tf_labhrv > `r(p50)' + (3*`r(sd)')
```

Take the steps to impute the values in **tf_labhrv** that we replaced with missing values.

```{s}

quietly	mi set 			wide 

quietly	mi xtset		, clear 

quietly	mi register 	imputed tf_labhrv

quietly	sort			hhid, stable 

	quietly mi impute 		pmm tf_labhrv i.state, add(1) rseed(245780) noisily dots ///
						force knn(5) bootstrap

	quietly mi unset

	replace			tf_labhrv = tf_labhrv_1_
	
quietly	drop 			tf_labhrv_1_
```
How has the maximum value of **tf_labhrv** changed now?

```{s}
sum 				tf_labhrv, detail
```
The maximum value is 21951.26 labor hours per hectare. This is stil too high to be realistic. Let's impute again.

```{s}
	replace 	tf_labhrv = . if tf_labhrv > `r(p50)' + (3*`r(sd)')
```

Take the steps to impute the values in **tf_labhrv** that we replaced with missing values.

```{s}

quietly	mi set 			wide 

quietly	mi xtset		, clear 

quietly	mi register 	imputed tf_labhrv

quietly	sort			hhid, stable 

	quietly mi impute 		pmm tf_labhrv i.state, add(1) rseed(245780) noisily dots ///
						force knn(5) bootstrap

	quietly mi unset

	replace			tf_labhrv = tf_labhrv_1_
	
quietly	drop 			tf_labhrv_1_
```
How has the maximum value of **tf_labhrv** changed now?

```{s}
sum 				tf_labhrv, detail
```
About 2000 labor days per hectare would be high but not too unrealistic if there are only a few observations at the top with that number. However, the max is 10421.5. We will impute again but this time we will replace any observations that are larger than 2000.

```{s}
	replace 	tf_labhrv = . if tf_labhrv > 2000
```

Take the steps to impute the values in **tf_labhrv** that we replaced with missing values.

```{s}

quietly	mi set 			wide 

quietly	mi xtset		, clear 

quietly	mi register 	imputed tf_labhrv

quietly	sort			hhid, stable 

	quietly mi impute 		pmm tf_labhrv i.state, add(1) rseed(245780) noisily dots ///
						force knn(5) bootstrap

	quietly mi unset

	replace			tf_labhrv = tf_labhrv_1_
	
quietly	drop 			tf_labhrv_1_
```
How has the maximum value of **tf_labhrv** changed now?

```{s}
sum 				tf_labhrv, detail
```
**tf_labhrv** is now much more realistic!

# Cleaning Planting Labor Variables

After the collapse the mean and maximum values of the planting labor variable **tf_labpp** became extremely high. Let's take a closer look at the variable to see what is going on.

```{s}
	sum				tf_labpp, detail
```

The top 10 percent of values of **tf_labpp** are driving the high means. So let's remove the outliers with an imputation. We will replac any values that are above 2000 labor days per hectare. For the sake of brevity we will provide the imputation code without much explanation, the steps for imputation are almost exactly the same as all the imputations we have already done. The only difference is **tf_labpp** is the variable we are imputing.

```{s}
	replace 	tf_labpp = . if tf_labpp > 2000
```

Take the steps to impute the values in **tf_labpp** that we replaced with missing values.

```{s}

quietly	mi set 			wide 

quietly	mi xtset		, clear 

quietly	mi register 	imputed tf_labpp

quietly	sort			hhid, stable 

	quietly mi impute 		pmm tf_labpp i.state, add(1) rseed(245780) noisily dots ///
						force knn(5) bootstrap

	quietly mi unset

	replace			tf_labpp = tf_labpp_1_
	
quietly	drop 			tf_labpp_1_
```
How has the maximum value of **tf_labpp** changed now?

```{s}
sum 				tf_labpp, detail
```
**tf_labpp** is now much more realistic!

That concludes the cleaning we will be doing on this data set. The dataset is now a complete dataset at the household level.


Save the file.



```{s}
	save "$root/wave_2/refined/fullproductiondataset.dta", replace	
```

# Conclusions

We have made a data set of household level agricultural production data from the Nigeria General Household Survey, Panel 2012-2013, Wave 2, the Living Standards Measurement Study - Integrated Surveys on Agriculture. The observations you decide to impute depends on what you expect to be reliable data for specific variables in specific contexts. For instance if a household with one hectares is recorded to have harvested 10,000 kilograms of maize we can assume that the data is unrealistic; however, if a household with 20 hectares harvested 10,000 kilograms of maize we can say that is possible. During the data cleaning phase the boundaries of what is reliable data are open to discussion.
