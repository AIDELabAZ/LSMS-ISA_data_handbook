% Merging Datasets and generating inputs and outputs in hectare terms in Nigeria General Household Survey, Panel 2012-2013, Wave 2
% Emil Kee-Tui 
% `s c(current_date)`

Total household maize yield (maize production in kilograms per hectare) is generated by dividing the total household maize production by the total area cultivated by a household for maize production. Recall from the crop_output and area_construct chapters that maize production data and area cultivated data are currently in two seperate files. In order to make the variable for the yield we must combine the maize production data with the area cultivation data. 

This chapter covers the procedures to produce variables on input and output per hectare as well as total input and output data, at the household level. Previous files we have thus far prepared are concerned with one type of input or output at the plot level. The purpose of this chapter is to produce a single file that contains all the input and output data at the household level. We will merge all of the preliminary datasets together and then we shall aggregate the data at the household level.

# Merge Datasets

Recall: our observations are identified at the crop level, the plot level, and the household level. When matching, all crops grown on the same plot should be matched to one another; all labor days used on the same plot should be matched to crops grown on that plot, all fertilizer applied to that plot should be matched to the crops grown on that plot and the labor used on that plot etc. The final dataset will be at the household level. To match data relating to the same household plot the two files must contain a household ID variable and a plot ID variable (**hhid** and **plotid**). We are able to identify the observations as belonging to the same household plot when the observations share a household ID and a plot ID. 

Let's now cover the merge itself. We must have one file already open before we start merging all the files together. Choosing the right file is not trivial. We should start with the largest file. Were we to start with a file which contains fewer household ids and plot ids then when we matched a larger file the extra household ids and plot ids would not be matched to the main file. Our largest file is the crop production file. The crop production file is identified for all crops and some crops were grown on the same plot, which means that there are multiple observations with the same plot id and household id.

We use crop output file "ph_secta3.dta" as the master file. We match observations on household id and plot id. During the merge, observations from the merging dataset will match if they possess a household id and plot id that exactly matches a household id and plot id in the master file. Households and plots that did not grow anything will not be present in the crop id; the observations that do not match are those without a crop output. 

```{s}
	use				"$root/wave_2/refined/ph_secta3.dta", clear 
```
	
We made an id variable **cropplot_id** when working on "sect3a_harvestw2.dta". Confirm that it uniquely identifies each observation with the `isid` command. Recall that when a variable uniquely identifies each observation `isid` will not display a result and when a variable fails to uniquely identify the observations `isid` will display an error.

```{s}
	isid			cropplot_id
```
	
Merge in plot size data, "sect11a1_plantingw2.dta", and merge on **hhid** and **plotid**. Multiple crops can be grown on one plot and multiple crops may be matched to the same plot, so; set the matching option to many to one (m:1). `generate(_11a1)` creates a variable called **_11a1** which tells us if an observation matched or failed to match. 

```{s}
	merge 			m:1 hhid plotid using "$root/wave_2/refined/sect11a1_plantingw2.dta", generate(_11a1)
```
	
A failed match from the master occurs if a household id and plot id are present in the master but there is no equal household id and plot id in the using dataset. A failed match from the "using" occurs if a household id and plot id are present in the using dataset but not in the master dataset.

Drop observations that did not match. Observations that did not match are plots that we cannot match to a crop or crops we cannot match to a plot. The only way to identify where a crop was grown or what crop was grown on a plot is the `merge` command we just executed - we cannot do much more. Recall all successful matches have **_11a1**=3. Note “!=” is equivalent to a "not equal" statement so let's use != to drop all observations not equal to 3.

```{s}
	drop			if _11a1 != 3
```

Merge the irrigation dataset, "pp_sect11b1.dta". Use the household id and the plot id for the match.
```{s}
	merge			m:1 hhid plotid using "$root/wave_2/refined/pp_sect11b1.dta", generate(_11b1)
```

A failed match from the master crop file implies that there was no irrigation match. We conclude that if there is no irrigation match to the plot then the plot did not have irrigation. Replace the **irr_any** response for the unmatched from master observations to '2' in order to show that those plots did not have irrigation.
	
```{s}
	replace			irr_any = 2 if irr_any == . & _11b1 == 1
```

Drop the observations from the "using" that are unmerged as we want to limit our observations to the plots with crop data.

```{s}
	drop			if _11b1 == 2
```
	
Merge in planting labor data, "pp_sect11c1.dta".

```{s}
	merge		m:1 hhid plotid using "$root/wave_2/refined/pp_sect11c1.dta", generate(_11c1)
```

Drop unmerged observations from the "using" since we cannot use labor that had no output. We will impute the missing planting labor from the "master" for any plots that had a non-zero crop production, presumably if anything was produced then it used labor to do so. (for the intuition and procedures on imputation refer to the chapter on planting_labor or the imputation section of the yield chapter (hyperlink to those places?))

```{s}
	drop			if _11c1 == 2
```

Merge in pesticide and herbicide use, "pp_sect11c2.dta".

```{s}
	merge		m:1 hhid plotid using "$root/wave_2/refined/pp_sect11c2.dta", generate(_11c2)
```

Failed matches would have occured because there was a household-id-plot-id present in one of the datasets and not the other. We can only confirm that pesticide was or was not used on a plot if they matched succesfully. What should we do about the unmatched observations? Let's consider what the data would look like if we kept the observations which did not match from the "using". The using dataset only contains information on herbicide and pesticide, so we would have no other data on those observations if we kept them in the dataset. What about if we kept the unmatched observations from the "master" file? Unmatched from the "master" have data on crop output, land area, and data from every other dataset we have already matched, but they do not have data on pesticide. We cannot assume that those observations had pesticide so to be on the safe side we should assume that they did not have pesticide use. It is more likely that if a plot had pesticide or herbicide then it would have been recorded in the "using" dataset. Replace the **pest_any** and **herb_any** responses for the unmatched from master observations to '2' in order to show that those plots did not have pesticide or herbicide.

Unfortunately, we must drop the unmatched observations from the "using", those are household-id-plot-ids we know nothing else about besides their pesticide use.

```{s}
	replace			pest_any = 2 if pest_any == . & _11c2 == 1
	replace			herb_any = 2 if herb_any == . & _11c2 == 1
```

Drop the unmerged observations from the using dataset, those observations are plots we do not have cropping data on and therefore cannot use.

```{s}
	drop			if _11c2 == 2
```

Merge the fertilizer dataset, "pp_sect11d.dta".

```{s}
	merge		m:1 hhid plotid using "$root/wave_2/refined/pp_sect11d.dta", generate(_11d)
```

As with the pesticide and herbicide merge, the umatched observations from the "using" dataset lack any other data on them besides fertilizer data. And umatched observations from the "master" dataset do not have fertilizer data but have data from all of the previous dataset merges. We have no information to assume that the plots unmatched from the "master" used fertilizer, so we should assume that those plots did not use fertilizer and replace their fertilizer data with "2", representing that no fertilizer was used on the plot. Drop unmerged observations from the "using" dataset - these are observations that we cannot match to a household or a plot and therefore we cannot use.

```{s}
	drop			if _11d == 2
	replace 		fert_any = 2 if _11d == 1
```

We proceed to merge in harvest labor data.

```{s}
	merge		m:1 hhid plotid using "$root/wave_2/refined/ph_secta2.dta", generate(_a2)
```

As with the planting labor we will impute the unmerged from master later (insert hyperlink to where the imputation occurs) and drop the unmerged from using. 

```{s}
	drop			if _a2 == 2
```

Now all the files have been merged. We have a lot of new variables, so we should drop any unnecessary variables to make the dataset maneagable. The merge variables will not be needed beyond this point, drop them.

```{s}
	drop 			_11a1 _11b _11c1 _11c2 _11d _a2
```

# Creating plot level total farm and maize variables

We now have everything in one place at the crop level, we want to make a set of variables that relate only to maize production, these variables will relate to maize labor, maize land, maize output, all such things that relate to maize. But first there are a few variables we must tidy up: the two labor variables, the fertilizer binary, the pesticide and herbicide binary, and the irrigation binary.

Labor is divided into two different variables: planting labor and harvest labor. The labor applied to the plot to produce the crop output is the sum of harvest and planting labor, so we add together those two labors. 

```{s}
	gen 			labordays = hrv_labor + pp_labor
	label var 		labordays "Total labor days used on plot"
```

Presently, our binary variables for fertilizer, herbicide, irrigation, and pesticide use 1 and 2 to represent yes and no, respectively. It is a convention in economics to represent a binary with a 0 and a 1. Recode the binary variables so that 0 instead of '2' represents a 'no' response. 

```{s}
	replace			fert_any = 0 if fert_any == 2
	replace			pest_any = 0 if pest_any == 2
	replace			herb_any = 0 if herb_any == 2
	replace			irr_any  = 0 if irr_any  == 2
```

Maize is an important crop and we may want to consider maize inputs and maize output seperately from the other crops or total farm production. We can create maize only variables for land, labor, fertilizer, pesticide, herbicide, and irrigation. We can identify maize observations when maize harvest is non-missing.

```{s}
	gen				mz_lnd = plotsize	if mz_hrv != .
	gen				mz_lab = labordays	if mz_hrv != .
	gen				mz_frt = fert_use	if mz_hrv != .
	gen				mz_pst = pest_any	if mz_hrv != .
	gen				mz_hrb = herb_any	if mz_hrv != .
	gen				mz_irr = irr_any	if mz_hrv != .
```

There are a lot of missing observations during the making of the maize observations. The missing observations are the non-maize observations. The maize variables will have non-missing observations when maize was grown and missing observations when maize was not grown.

# Collapsing the data to the plot level

The data is currently at the crop level and we want the data to be at the household level. Between the crop level and the household level is the plot level. The crops are grown on a plot and the plot belongs to the household. We must first collapse the crop level data to the plot level, then we shall collapse the plot level data to the household level. The process of moving from a lower level of data aggregation to a higher level of aggregation is known as collapsing. After collapsing the data, all crops grown on the same plot will be aggregated into one entry. After the collapse, output will be a sum of the total value of all crops grown on that plot.

We use the `collapse` command to aggregate the data to the plot level. Before we collapse note, currently there may be multiple entries for a single plot, the same plot may have matched with multiple crops. We want to condense multiple crop entries into a single entry that summarizes all the crop data for one plot. We have to decide how to aggregate multiple crops, in this case adding them together is best option. Write the option `(sum)' after `collapse' to get the total weight of maize harvested from the plot. Plot size should not be summed because the crops grown on the same plot will have duplicated the same plot size data. Therefore, to create plot size take the maximum value of the plot size. 

Binaries should be collapsed taking the maximum observation. Write the option `(max)' after `collapse' to get the maximum of the binary variable. The observations are either 0 or 1, taking the maximum will preserve the binary. **Labordays** should be collapsed by summation for the same justification as for output, discussed above.

The most important part of the `collapse' command is the level of aggregation of the collapse. At the end of the command we have a `by()' option. In the set of observations that have the same values for the variables in the by option calculate the collapse condition. For instance we could collapse using addition output `by(hhid plotid)', in doing so all observations that share the same **hhid** and **plotid** will be aggregated together.

```{s}
	collapse (sum) mz_vl vl_hrv harv_kg plotsize labordays fert_use mz_hrv mz_lnd mz_lab mz_frt (max) pest_any herb_any irr_any mz_pst mz_hrb mz_irr, by(hhid plotid plot_id zone state lga sector ea)
```

Now that the data is at the plot level we should make the variables that are at the plot level such as crop yield (kg/ha).

# Construct maize yield (kg/ha).

```{s}
	gen			mz_yld = mz_hrv / mz_lnd
	lab var		mz_yld	"maize yield (kg/ha)"
```

It is important to summarize the variable we have just produced, at a quick glance we can check for glaring mistakes. Look at the summary statistics: mean values, maximum values, and minimum values. We want to make sure that the data reflects something about what we know the actual production in Nigeria.

```{s}
	sum 		mz_yld, detail
```

The **mz_yld** turns out to have large values. We should replace the very large outliers and impute the missing observations outliers. We have repeated the steps to impute many times in the previous chapters so for brevity we will not describe here how imputation works (see crop_output chapter), we will lay out the steps and highlight the parts of the code which are specific to this case. 

As with any imputation we must first decide which outliers we wish to target. Observations which are greater than 3 standard deviations from the mean we will change to missing.

```{s}
	replace 	mz_yld = . if mz_yld > `r(p50)' + (3*`r(sd)')
```

`Mi` (multiple imputation) is the Stata command for imputing. Set the data structure as wide or long. Our data is wide because a unique observation is identified by a unique row.

```{s}

	mi set 			wide 
```	
Clear any time series settings you may have in place or else the time series will interfere with the linear regression we run later.
```{s}

	mi xtset		, clear 
```
Register **mz_yld** as the variable we will be imputing.
	
```{s}

	mi register 	imputed mz_yld
```
Sort the data to ensure reproducibility. Sorting the data can be done at any stage before the actual imputation. Data is uniquely identified by **hhid** **plotid**. 

```{s}

	sort			hhid plotid, stable 
```
	
Use predictive mean matching (pmm) to impute the data, the regression in the imputation has **mz_yld** for the dependent variable and **i.state** (a dummy for each state) as the independent variable. Enable the impute option "force" which enables the regression to run even if an error occurs; "knn(#)" determines the number of non-missing **mz_yld** observations to match to the estimate, for example we choose to match to the nearest 5 observations; "bootstrap" samples the data with replacement and regresses on the bootstapped sample; "rseed(#)" specifies the random number seed used to create the sample. 


```{s}
	quietly mi impute 		pmm mz_yld i.state, add(1) rseed(245780) noisily dots ///
						force knn(5) bootstrap
```
Declare the imputing to be over by `mi unset`.

```{s}

	quietly mi unset
```

Do the changes look reasonable? If they are reasonable then we can replace the missing values with the imputed values.

```{s}
	replace			mz_yld = mz_yld_1_ if mz_lnd != .
	drop 			mz_yld_1_
```

The maize yield variable is imputed meaning its different from what it was when we first labeled it. Relabel it to track the change of imputation.

```{s}
	lab var 		mz_yld "maize yield (kg/ha), imputed"
```
Having now cleaned **mz_yld (kg/ha)** we can calculate the total maize output for a field by multiplying the yield with the plotsize.

```{s}
	generate 		mz_hrvimp = mz_yld * mz_lnd
	lab var 		mz_hrvimp "maize harvest quantity (kg), imputed"
```

# Maize value (USD/ha)

```{s}
	gen 		mz_value = mz_vl / mz_lnd
	lab var 	mz_value "maize value (USD/ha)"

	sum 		mz_value, detail

	replace 	mz_value = . if mz_value > `r(p50)' + (3*`r(sd)')
```

For the sake of brevity we have included the imputation code for **mz_value** but we have not included any discussion of our approach to imputation (refer to chapter crop_output for a discussion about imputation).

```{s}
	mi set 			wide 

	mi xtset		, clear 

	mi register 	imputed mz_value

	sort			hhid plotid, stable 

	quietly mi impute 		pmm mz_value i.state, add(1) rseed(245780) noisily dots ///
						force knn(5) bootstrap

	quietly mi unset

	replace			mz_value = mz_value_1_ if mz_lnd != .
	
	drop 			mz_value_1_
```

# Maize Labor Days Per Hectare (days/ha)

Create the maize labor used per hectare variable.

```{s}
	gen 		labordays_ha_mz = labordays/plotsize
	label var 	labordays_ha_mz "maize labor use (days/ha)"
```
Summarize the maize labor per hectare to obtain the standard deviation, all observations above 3 standard deviations from the mean will be replaced with missing values and imputed.
```{s}
	sum 		labordays_ha_mz, detail

	replace 	labordays_ha_mz = . if labordays_ha_mz > `r(p50)' + (3*`r(sd)')
```

Impute the missing observations.

```{s}
	mi set 			wide 

	mi xtset		, clear 

	mi register 	imputed labordays_ha_mz

	sort			hhid plotid, stable 

	quietly mi impute 		pmm labordays_ha_mz i.state, add(1) rseed(245780) noisily dots ///
						force knn(5) bootstrap

	quietly mi unset

	replace			labordays_ha_mz = labordays_ha_mz_1_
	
	drop 			labordays_ha_mz_1_
```

Relabel the maize labor variable to keep track of that the variable has been imputed.

```{s}
		lab var			labordays_ha_mz	"maize labor use (days/ha), imputed"
```

Infer total maize labor use with the per hectare labor use.

```{s}
	gen				mz_labimp = labordays_ha_mz * mz_lnd
	lab var			mz_labimp "maize labor (days), imputed"
```

# Fertilizer Application Per Hectare, Used on Maize (kg/ha)

Create the fertilizer use variable. Fertilizer use is measured as kilograms of fertilizer applied per hectare.

```{s}
	gen 		fert_use_ha_mz = fert_use/plotsize if mz_lnd != .
	label var 	fert_use_ha_mz "fertilizer applied per hectare, maize (kg/ha)"
```

Summarize the fertilizer use per hectare to obtain the standard deviation, all observations above 3 standard deviations from the mean will be replaced with missing values and imputed.

```{s}
	sum 		fert_use_ha_mz, detail
	replace 	fert_use_ha_mz = . if fert_use_ha_mz > `r(p50)' + (3*`r(sd)')
```
Impute the missing fertilizer use values.

```{s}
	mi set 			wide 

	mi xtset		, clear 

	mi register 	imputed fert_use_ha_mz

	sort			hhid plotid, stable 

	quietly mi impute 		pmm fert_use_ha_mz i.state, add(1) rseed(245780) noisily dots ///
						force knn(5) bootstrap

	quietly mi unset

	replace			fert_use_ha_mz = fert_use_ha_mz_1_
	
	drop 			fert_use_ha_mz_1_
```

Relabel the fertililzer variable to keep track of the imputation.

```{s}
	label		var	fert_use_ha_mz "fertilizer applied per hectare, maize (kg/ha) imputed"
```

Infer the total fertilizer used from the per hectare measure.

```{s}
	gen				mz_frtimp = fert_use_ha_mz * mz_lnd
	lab var			mz_frtimp "fertilizer (kg), imputed"
```

# Plot Total Crop Yield (kg/ha)

Generate yield of all crops on each plot. Yield is measured in kilograms of output per hectare. Generate total plot yield by dividing **harv_kg**, the weight of all crops harvested on the plot, by **plotsize**, the size of the plot in hectares.

```{s}
	gen 		kg_yld = harv_kg / plotsize
	label var   kg_yld "total crop yield (kg/ha)"
```

Summarize **kg_yld**, notice the extreme values, if the values appear to be too large then we will replace the high values with missing values and impute the missing values.

```{s}
	sum 		kg_yld, detail
```

The maximum value is 2114473 kg/ha, clearly this is unrealistic. Replace all values that are greater than 3 standard deviations from the mean.

```{s}
	replace 	kg_yld = . if kg_yld > `r(p50)' + (3*`r(sd)')
```

Take the steps to impute the values in **kg_yld** that we replaced with missing values.

```{s}

	mi set 			wide 

	mi xtset		, clear 

	mi register 	imputed kg_yld

	sort			hhid plotid, stable 

	quietly mi impute 		pmm kg_yld i.state, add(1) rseed(245780) noisily dots ///
						force knn(5) bootstrap

	quietly mi unset

	replace			kg_yld = kg_yld_1_
	
	drop 			kg_yld_1_
```
	
# Harvest value (USD/ha)

Generate harvest value and give it a label. 

```{s}
	gen 		harv_value = vl_hrv/plotsize if mz_hrv != .
	label var 	harv_value "total value of crop harvest (USD/ha)"
```

Summarize **harv_value** to obtain the standard deviation, replace the values outside of 3 standard deviations as missing in preperation for the imputation.

```{s}
	quietly sum 		harv_value, detail

	replace 	harv_value = . if harv_value > `r(p50)' + (3*`r(sd)')
```
Impute the missing variables.

```{s}
	mi set 			wide 

	mi xtset		, clear 

	mi register 	imputed harv_value

	sort			hhid plotid, stable 

	quietly mi impute 		pmm harv_value i.state, add(1) rseed(245780) noisily dots ///
						force knn(5) bootstrap

	quietly mi unset

	replace			harv_value = harv_value_1_
	
	drop 			harv_value_1_
	
```

Relabel the imputed variable to keep track of the imputation.

```{s}
	lab var			harv_value	"value of yield (2010USD/ha), imputed"
```
Infer the total value of the harvest by multiplying the imputed value of crop per hectare with the land area.

```{s}
	generate		vl_hrvimp = harv_value * plotsize 
	lab var			vl_hrvimp "value of harvest (2010USD), imputed"
```

# Total Labor days per hectare (days/ha)

```{s}
	gen 		labordays_ha = labordays/plotsize
	label var 	labordays_ha "farm labor use (labordays/ha)"
	quietly sum 		labordays_ha, detail

	replace 	labordays_ha = . if labordays_ha > `r(p50)' + (3*`r(sd)')
	
	mi set 			wide 

	mi xtset		, clear 

	mi register 	imputed labordays_ha

	sort			hhid plotid, stable 

	quietly mi impute 		pmm labordays_ha i.state, add(1) rseed(245780) noisily dots ///
						force knn(5) bootstrap

	quietly mi unset

	replace			labordays_ha = labordays_ha_1_
	
	drop 			labordays_ha_1_
```

Relabel the labordays variable to indicate it has undergone imputing.

```{s}
	lab var			labordays_ha	"farm labor use (days/ha), imputed"
```

Infer the total labor used on the plot by multiplying the imputed labor per hectare with the plotsize.

```{s}
	gen				labordaysimp = labordays_ha * plotsize
	lab var			labordaysimp "farm labor (days), imputed"
```

# Fertilizer application per hectare (kg/ha)

```{s}
	gen 		fert_use_ha = fert_use/plotsize
	label var 	fert_use_ha "fertilizer applied per hectare (kg/ha)"
	quietly sum 		fert_use_ha, detail

	replace 	fert_use_ha = . if fert_use_ha > `r(p50)' + (3*`r(sd)')
	
	mi set 			wide 

	mi xtset		, clear 

	mi register 	imputed fert_use_ha

	sort			hhid plotid, stable 

	quietly mi impute 		pmm fert_use_ha i.state, add(1) rseed(245780) noisily dots ///
						force knn(5) bootstrap

	quietly mi unset

	replace			fert_use_ha = fert_use_ha_1_
	
	drop 			fert_use_ha_1_
```

Relabel the fertililzer use variable to indicate it has undergone imputing.

```{s}
	lab var			fert_use_ha	"fertilizer applied per hectare (kg/ha), imputed"
```

Infer the total fertilizer used on the plot by multiplying the imputed rate at which fertilizer is applied by the plot area.

```{s}
	gen fertimp = fert_use_ha*plotsize
```

# Collapsing to the household level

We already have variables in per hectare terms at the plot level, we will generate the household level variables before we collapse, and we will apply collapse by taking the maximum values of the household variable. The steps are in the reverse order to the last collapse which was collapsing first then generating plot level variables. The new approach produces the same result. We will be making variables which have the same values for all observations with the same household id. 

We make the household level variable by summarizing the values within a household. So that the new value for a household's observation in a particular variable is the sum of all plot values.

For total household land, by hhid take the sum of all plotsizes with a unique plot_id.
```{s}
	bysort			hhid (plot_id) : egen tf_lnd = sum(plotsize)
```
We must name our new variable. 

```{s}
	lab var			tf_lnd	"Total farmed area (ha)"
```

And land measurements must be positive and because we will be dividing by land measurements to generate per hectare variables land must be non-zero. We can force the data to be non-zero and non-negative by asserting a non-negative non-zero condition on **tf_lnd**. Assert will notify us if any observations do not meet the conditions, at least non-negative observations are definitely errors, true 0 land observations should be dropped because a crop cannot be grown on no land.

```{s}
	assert			tf_lnd > 0 
```

For total household harvest, by hhid take the sum of all harvest which come from a unique plot_id.

```{s}
	bysort			hhid (plot_id) : egen tf_hrv = sum(vl_hrvimp)
```

We must label our new variable. 

```{s}
	lab var			tf_hrv	"Total value of harvest (2010 USD)"
```
	
We now make the total yield. The total yield is the total harvest value divided by the total land. All observations from the same household have the same values for **tf_hrv** and **tf_lnd**, thus **tf_yld** will also have the same values for all observations which have the same household id. We want to preserve the **tf_yld** value which appears identically sometimes in several observations, using maximum **tf_yld** for collapse will preserve the value.

```{s}
	generate		tf_yld = tf_hrv / tf_lnd
``` 

Label our new variable.

```{s}
	lab var			tf_yld	"value of yield (2010 USD/ha)"
``` 

For total labor we will generate a new variable which is the sum of all plot labor by household.

```{s}
	bysort 			hhid (plot_id) : egen lab_tot = sum(labordays_ha)
``` 

We now make the total labor. The total labor is the total labor divided by the total land. All observations from the same household have the same values for **lab_tot** and **tf_lnd**, thus **tf_lab** will also have the same values for all observations which have the same household id. We want to preserve the **tf_lab** value which appears identically sometimes in several observations, using maximum **tf_lab** for collapse will preserve the value.

```{s}
	generate		tf_lab = lab_tot / tf_lnd
``` 

Label our new variable.

```{s}
	lab var			tf_lab	"labor rate (days/ha)"
```

For total fertilizer we will generate a new variable which is the sum of all plot fertilizer by household.

```{s}
	bysort 			hhid (plot_id) : egen fert_tot = sum(fertimp)
``` 
We now make the total fertilizer. The total fertilizer is the total fertilizer value divided by the total land. All observations from the same household have the same values for **fert_tot** and **tf_lnd**, thus **tf_frt** will also have the same values for all observations which have the same household id. We want to preserve the **tf_frt** value which appears identically sometimes in several observations, using maximum **tf_frt** for collapse will preserve the value.

```{s}
	generate		tf_frt = fert_tot / tf_lnd
``` 

Label our new variable.

```{s}
	lab var			tf_frt	"fertilizer rate (kg/ha)"
``` 

For pesticide and herbicide we do not have the amount of pesticide or herbicide or irrigation so we can be contented to represent the binary that pesticide was applied on a plot to an equivalent binary that a household used pesticide on at least one of their plots, this we generate by taking the maximum **irr_any** or **pest_any** or **herb_any** binary value for all plots within a household.

```{s}
	bysort 			hhid (plot_id) : egen tf_pst = max(pest_any)
	bysort 			hhid (plot_id) : egen tf_hrb = max(herb_any)
	bysort 			hhid (plot_id) : egen tf_irr = max(irr_any)
``` 
Label the variables.

```{s}
	lab var			tf_pst	"Any plot has pesticide"
	lab var			tf_hrb	"Any plot has herbicide"
	lab var			tf_irr	"Any plot has irrigation"
``` 

Let's now generate household level maize variables, we will use the same procedures as the household level total farm variables.

For household maize land, by hhid take the sum of all maize plotsizes with a unique maize plot_id.

```{s}
	bysort			hhid (plot_id) :	egen cp_lnd = sum(mz_lnd) if mz_hrvimp != .
```

For household maize harvest, by hhid take the sum of all harvest which come from a unique maize plot_id.

```{s}
	bysort			hhid (plot_id) :	egen cp_hrv = sum(mz_hrvimp) if mz_hrvimp != .
```
	
For household maize yield, by hhid divide the maize harvest by the maize land from a unique maize plot_id.

```{s}
	generate		cp_yld = cp_hrv / cp_lnd if mz_hrvimp != .
```
	
For household maize labor, by hhid take the sum of all labor which come from a unique maize plot_id.

```{s}
	bysort 			hhid (plot_id) : egen lab_mz = sum(mz_labimp)	if mz_hrvimp != .
```

For the household rate at which labor was applied to maize fields, by hhid divide the maize labor by the maize land from a unique maize plot_id.

```{s}
	generate		cp_lab = lab_mz / cp_lnd
```

For the household rate at which fertilizer was applied to maize fields, by hhid divide the maize fertilizer by the maize land from a unique maize plot_id.

```{s}
	bysort 			hhid (plot_id) : egen fert_mz = sum(mz_frtimp) if mz_hrvimp != .
	generate		cp_frt = fert_mz / cp_lnd
```

For pesticide and herbicide we do not have the amount of pesticide or herbicide or irrigation so we can be contented to represent the binary that pesticide was applied on a plot to an equivalent binary that a household used pesticide on at least one of their plots, this we generate by taking the maximum **irr_any** or **pest_any** or **herb_any** binary value for all plots within a household. One difference is that the variable we want now is the maize variable so we only take observations that have a non-missing maize harvest.

```{s}
	bysort 			hhid (plot_id) : egen cp_pst = max(pest_any) if mz_hrvimp != .
	bysort 			hhid (plot_id) : egen cp_hrb = max(herb_any) if mz_hrvimp != .
	bysort 			hhid (plot_id) : egen cp_irr = max(irr_any) if mz_hrvimp != .
``` 	
	
Having made all the variables we can now collapse the data to the household level. The variables we made are already at the household level so we only need to take the maximum values of those variables. At the moment the data consists of several observations per household depending on how many plots the household owns. However now we will be left with one observation per household.

```{s}
	collapse (max)	tf_* cp_*, by(zone state lga sector ea hhid)		
```
All at once we're going to label the new variables.

```{s}
	lab var			tf_lnd	"Total farmed area (ha)"
	lab var			tf_hrv	"Total value of harvest (2010 USD)"
	lab var			tf_yld	"value of yield (2010 USD/ha)"
	lab var			tf_lab	"labor rate (days/ha)"
	lab var			tf_frt	"fertilizer rate (kg/ha)"
	lab var			tf_pst	"Any plot has pesticide"
	lab var			tf_hrb	"Any plot has herbicide"
	lab var			tf_irr	"Any plot has irrigation"
	lab var			cp_lnd	"Total maize area (ha)"
	lab var			cp_hrv	"Total quantity of maize harvest (kg)"
	lab var			cp_yld	"Maize yield (kg/ha)"
	lab var			cp_lab	"labor rate for maize (days/ha)"
	lab var			cp_frt	"fertilizer rate for maize (kg/ha)"
	lab var			cp_pst	"Any maize plot has pesticide"
	lab var			cp_hrb	"Any maize plot has herbicide"
	lab var			cp_irr	"Any maize plot has irrigation"
```

We must now make sure that the observations are accurate and this will mean summarizing observations and imputing the large outliers.
	
```{s}
	sum				tf_* cp_*
```

All

Save the file.

```{s}
	save "$root/wave_2/refined/secta3_harvestw2.dta", replace	
```

	
# Citations

Kilic, T., Zezza, A., Carletto, C., & Savastano, S. (2017). Missing (ness) in action: selectivity bias in GPS-based land area measurements. World Development, 92, 143-157.
